# JDT Extensions

This is a patch for Eclipse JDT to add support a few Java extensions, inspired by
[Project Lombok](https://projectlombok.org).

Important: source files using any of these features can only be compiled by a patched Eclipse IDE.

## List of extensions

### `var` keyword

Allows to use C#-style type inference using the `var` keyword (for local variables and collection iterators).

Implementation extracted from Project Lombok but integrated directly into the JDT.

```java
var list = new LinkedList<String()>();

list.add("hello");
list.add(" world!");

for (var s: list) {
	System.out.print(s);
}
System.out.println();
```

### Default argument values

Same as C++ or C# default argument values, allows to specify default values for method parameters.

Note: this will automatically generate appropriate method overload(s), just like this would be done in "plain" Java.
Any valid expression valid in the context of the overloaded method can be used, including referencing other arguments
(provided they do not have a default value).

```java
class Test {	

	static void sayHello(String who = "world") {
		System.out.println("Hello " + who + "!");
	}
	
	// The following method will be automatically generated
	static void sayHello() {
		sayHello("world");
	}
	
	static void main(String[] args) {
		sayHello();
	}
}
```

### Caller annotations

Inspired by C#, mostly intended for diagnostics:

* `@CallIf`: on a method, allows to disable all calls to a specific method (including parameter evaluation!).

Useful for logging or assertion methods. Corresponds to the `Conditional` C# attribute.

```java
class Test {
	
	@CallIf(false)
	static void disabled(Object arg) {
	}
	
	@CallIf(true)
	static void enabled(Object arg) {
	}
	
	static void main(String[] args) {
		var hello = "Hello";
		disabled(hello = hello + " world!");
		System.out.println(hello); // Hello
		enabled(hello = hello + " world!");
		System.out.println(hello); // Hello world!
	}
}
```

* `@CallFile`, `@CallLine`, `@CallClass`, `@CallMethod`: on a method parameter, replaced by the corresponding value in the caller's context.

Corresponds to the `Caller...` C# attributes.

```java
class Test {
	
	static void print(@CallFile String callFile, @CallLine int callLine, @CallClass String callClass, @CallMethod String callMethod, String message, Object ...args) {
		var output = new StringBuilder();
		var callFileName = new File(callFile).getName();
		output.append("(").append(callFileName).append(":").append(callLine).append("): ").append(callClass).append(".").append(callMethod).append(": ");
		output.append(String.format(message, args));
		System.out.println(output);
	}
	
	static void main(String[] args) {
		var world = "world";
		print("Hello %s!", world); // (Test.java:64): Test.main: Hello world!
	}
}
```

* `@CallArg`, `@CallArgs`: on a method parameter, filled with the string representation of the value used for the following argument (@`CallArg`) or all non-synthetic arguments (`@CallArgs`).

Corresponds to the `nameof` C# operator.

```java
class Test {

	static String display(@CallArg String objName, Object objValue) {
		return objName + " = " + objValue;
	}
	
	static String displayAll(@CallArgs String[] objNames, Object ...objValues) {
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < objValues.length; i++) {
			if (i > 0) builder.append(", ");
			builder.append(objNames[i]).append(" = ").append(objValues[i]);
		}
		return builder.toString();
	}
	
	static void main(String[] args) {
		var hello = "Hello";  
		System.out.println(display(hello)); // hello = Hello
		var world = "world";
		System.out.println(displayAll(hello, world, hello + " " + world + "!")); // hello = Hello, world = world, hello + " " + world + "!" = Hello world!
	}
}
```

Note: these are "synthetic" annotations, in the sense that the arguments are always generated by the compiler (unlike optional arguments).

The main advantage of this approach is that these parameters do not need to appear last and so can combined with variable number of arguments (very useful for logging). This is unlike the corresponding C# annotations.

### Public by default

This sets the default access protection to public instead of Package-Private for a project. To enable, simply add to following to `${Workspace}/${Project}/.settings/org.eclipse.jdt.core.prefs`:

```
org.eclipse.jdt.core.compiler.extensions.publicByDefault=enabled
```

Not for everyone obviously but nice when you just want to write code for a personal/prototype project and worry about
encapsulation later (or never).

```java
class Hello {

	static void main(String[] args) { // would not run normally since not public
		System.out.println("Hello!");
	}
}
```

## Installation

To install the patch:

1. Download the zip archive `eclipse.jdt.extensions.zip`.
2. Use "Help" --> "Install New Software" --> "Add" --> "Archive".

## Implementation notes

The feature patch is produced from a fork of Eclipse JDT [core](https://github.com/philippejer/eclipse.jdt.core/tree/extensions) and [UI](https://github.com/philippejer/eclipse.jdt.ui/tree/extensions) repositories.

Unlike project Lombok, this is not intended to be portable to other compilers or IDEs. This allows to insert the required hooks into the JDT code directly instead of using complicated code injection via reflection. Also, this is not intended as a "clean" implementation, i.e. it is not tightly coupled with the JDT code. This means it can be merged easily with the official repositories.

Note: since this is non-standard Java extensions, code using these features can only be compiled by a patched Eclipse JDT. However the resulting bytecode is perfectly normal and will be optimized at runtime by the JIT compiler.